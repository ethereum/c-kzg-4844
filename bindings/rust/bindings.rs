/* automatically generated by rust-bindgen 0.61.0 */

use libc::{fopen, FILE};

pub const BYTES_PER_COMMITMENT: u32 = 48;
pub const BYTES_PER_PROOF: u32 = 48;
pub const FIELD_ELEMENTS_PER_BLOB: u32 = 4096;
pub const BYTES_PER_FIELD_ELEMENT: u32 = 32;
pub const BYTES_PER_BLOB: u32 = 131072;

pub type byte = u8;
pub type limb_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct blst_scalar {
    pub b: [byte; 32usize],
}
#[test]
fn bindgen_test_layout_blst_scalar() {
    const UNINIT: ::std::mem::MaybeUninit<blst_scalar> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blst_scalar>(),
        32usize,
        concat!("Size of: ", stringify!(blst_scalar))
    );
    assert_eq!(
        ::std::mem::align_of::<blst_scalar>(),
        1usize,
        concat!("Alignment of ", stringify!(blst_scalar))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blst_scalar),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct blst_fr {
    pub l: [limb_t; 4usize],
}
#[test]
fn bindgen_test_layout_blst_fr() {
    const UNINIT: ::std::mem::MaybeUninit<blst_fr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blst_fr>(),
        32usize,
        concat!("Size of: ", stringify!(blst_fr))
    );
    assert_eq!(
        ::std::mem::align_of::<blst_fr>(),
        8usize,
        concat!("Alignment of ", stringify!(blst_fr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blst_fr),
            "::",
            stringify!(l)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct blst_fp {
    pub l: [limb_t; 6usize],
}
#[test]
fn bindgen_test_layout_blst_fp() {
    const UNINIT: ::std::mem::MaybeUninit<blst_fp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blst_fp>(),
        48usize,
        concat!("Size of: ", stringify!(blst_fp))
    );
    assert_eq!(
        ::std::mem::align_of::<blst_fp>(),
        8usize,
        concat!("Alignment of ", stringify!(blst_fp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blst_fp),
            "::",
            stringify!(l)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct blst_fp2 {
    pub fp: [blst_fp; 2usize],
}
#[test]
fn bindgen_test_layout_blst_fp2() {
    const UNINIT: ::std::mem::MaybeUninit<blst_fp2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blst_fp2>(),
        96usize,
        concat!("Size of: ", stringify!(blst_fp2))
    );
    assert_eq!(
        ::std::mem::align_of::<blst_fp2>(),
        8usize,
        concat!("Alignment of ", stringify!(blst_fp2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blst_fp2),
            "::",
            stringify!(fp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct blst_fp6 {
    pub fp2: [blst_fp2; 3usize],
}
#[test]
fn bindgen_test_layout_blst_fp6() {
    const UNINIT: ::std::mem::MaybeUninit<blst_fp6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blst_fp6>(),
        288usize,
        concat!("Size of: ", stringify!(blst_fp6))
    );
    assert_eq!(
        ::std::mem::align_of::<blst_fp6>(),
        8usize,
        concat!("Alignment of ", stringify!(blst_fp6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blst_fp6),
            "::",
            stringify!(fp2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct blst_fp12 {
    pub fp6: [blst_fp6; 2usize],
}
#[test]
fn bindgen_test_layout_blst_fp12() {
    const UNINIT: ::std::mem::MaybeUninit<blst_fp12> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blst_fp12>(),
        576usize,
        concat!("Size of: ", stringify!(blst_fp12))
    );
    assert_eq!(
        ::std::mem::align_of::<blst_fp12>(),
        8usize,
        concat!("Alignment of ", stringify!(blst_fp12))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blst_fp12),
            "::",
            stringify!(fp6)
        )
    );
}

#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct blst_p1 {
    pub x: blst_fp,
    pub y: blst_fp,
    pub z: blst_fp,
}
#[test]
fn bindgen_test_layout_blst_p1() {
    const UNINIT: ::std::mem::MaybeUninit<blst_p1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blst_p1>(),
        144usize,
        concat!("Size of: ", stringify!(blst_p1))
    );
    assert_eq!(
        ::std::mem::align_of::<blst_p1>(),
        8usize,
        concat!("Alignment of ", stringify!(blst_p1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blst_p1),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(blst_p1),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(blst_p1),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct blst_p1_affine {
    pub x: blst_fp,
    pub y: blst_fp,
}
#[test]
fn bindgen_test_layout_blst_p1_affine() {
    const UNINIT: ::std::mem::MaybeUninit<blst_p1_affine> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blst_p1_affine>(),
        96usize,
        concat!("Size of: ", stringify!(blst_p1_affine))
    );
    assert_eq!(
        ::std::mem::align_of::<blst_p1_affine>(),
        8usize,
        concat!("Alignment of ", stringify!(blst_p1_affine))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blst_p1_affine),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(blst_p1_affine),
            "::",
            stringify!(y)
        )
    );
}

#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct blst_p2 {
    pub x: blst_fp2,
    pub y: blst_fp2,
    pub z: blst_fp2,
}
#[test]
fn bindgen_test_layout_blst_p2() {
    const UNINIT: ::std::mem::MaybeUninit<blst_p2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blst_p2>(),
        288usize,
        concat!("Size of: ", stringify!(blst_p2))
    );
    assert_eq!(
        ::std::mem::align_of::<blst_p2>(),
        8usize,
        concat!("Alignment of ", stringify!(blst_p2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blst_p2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(blst_p2),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(blst_p2),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct blst_p2_affine {
    pub x: blst_fp2,
    pub y: blst_fp2,
}
#[test]
fn bindgen_test_layout_blst_p2_affine() {
    const UNINIT: ::std::mem::MaybeUninit<blst_p2_affine> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blst_p2_affine>(),
        192usize,
        concat!("Size of: ", stringify!(blst_p2_affine))
    );
    assert_eq!(
        ::std::mem::align_of::<blst_p2_affine>(),
        8usize,
        concat!("Alignment of ", stringify!(blst_p2_affine))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blst_p2_affine),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(blst_p2_affine),
            "::",
            stringify!(y)
        )
    );
}
extern "C" {
    pub fn blst_p2_add(out: *mut blst_p2, a: *const blst_p2, b: *const blst_p2);
}
extern "C" {
    pub fn blst_p2_add_or_double(out: *mut blst_p2, a: *const blst_p2, b: *const blst_p2);
}
extern "C" {
    pub fn blst_p2_add_affine(out: *mut blst_p2, a: *const blst_p2, b: *const blst_p2_affine);
}
extern "C" {
    pub fn blst_p2_add_or_double_affine(
        out: *mut blst_p2,
        a: *const blst_p2,
        b: *const blst_p2_affine,
    );
}
extern "C" {
    pub fn blst_p2_double(out: *mut blst_p2, a: *const blst_p2);
}
extern "C" {
    pub fn blst_p2_mult(out: *mut blst_p2, p: *const blst_p2, scalar: *const byte, nbits: usize);
}
extern "C" {
    pub fn blst_p2_cneg(p: *mut blst_p2, cbit: bool);
}
extern "C" {
    pub fn blst_p2_to_affine(out: *mut blst_p2_affine, in_: *const blst_p2);
}
extern "C" {
    pub fn blst_p2_from_affine(out: *mut blst_p2, in_: *const blst_p2_affine);
}
extern "C" {
    pub fn blst_p2_on_curve(p: *const blst_p2) -> bool;
}
extern "C" {
    pub fn blst_p2_in_g2(p: *const blst_p2) -> bool;
}
extern "C" {
    pub fn blst_p2_is_equal(a: *const blst_p2, b: *const blst_p2) -> bool;
}
extern "C" {
    pub fn blst_p2_is_inf(a: *const blst_p2) -> bool;
}
extern "C" {
    pub fn blst_p2_generator() -> *const blst_p2;
}
extern "C" {
    pub fn blst_p2_affine_on_curve(p: *const blst_p2_affine) -> bool;
}
extern "C" {
    pub fn blst_p2_affine_in_g2(p: *const blst_p2_affine) -> bool;
}
extern "C" {
    pub fn blst_p2_affine_is_equal(a: *const blst_p2_affine, b: *const blst_p2_affine) -> bool;
}
extern "C" {
    pub fn blst_p2_affine_is_inf(a: *const blst_p2_affine) -> bool;
}
extern "C" {
    pub fn blst_p2_affine_generator() -> *const blst_p2_affine;
}
extern "C" {
    pub fn blst_p1s_to_affine(
        dst: *mut blst_p1_affine,
        points: *const *const blst_p1,
        npoints: usize,
    );
}
extern "C" {
    pub fn blst_p1s_add(ret: *mut blst_p1, points: *const *const blst_p1_affine, npoints: usize);
}
extern "C" {
    pub fn blst_p1s_mult_wbits_precompute_sizeof(wbits: usize, npoints: usize) -> usize;
}
extern "C" {
    pub fn blst_p1s_mult_wbits_precompute(
        table: *mut blst_p1_affine,
        wbits: usize,
        points: *const *const blst_p1_affine,
        npoints: usize,
    );
}
extern "C" {
    pub fn blst_p1s_mult_wbits_scratch_sizeof(npoints: usize) -> usize;
}
extern "C" {
    pub fn blst_p1s_mult_wbits(
        ret: *mut blst_p1,
        table: *const blst_p1_affine,
        wbits: usize,
        npoints: usize,
        scalars: *const *const byte,
        nbits: usize,
        scratch: *mut limb_t,
    );
}
extern "C" {
    pub fn blst_p1s_mult_pippenger_scratch_sizeof(npoints: usize) -> usize;
}
extern "C" {
    pub fn blst_p1s_mult_pippenger(
        ret: *mut blst_p1,
        points: *const *const blst_p1_affine,
        npoints: usize,
        scalars: *const *const byte,
        nbits: usize,
        scratch: *mut limb_t,
    );
}
extern "C" {
    pub fn blst_p1s_tile_pippenger(
        ret: *mut blst_p1,
        points: *const *const blst_p1_affine,
        npoints: usize,
        scalars: *const *const byte,
        nbits: usize,
        scratch: *mut limb_t,
        bit0: usize,
        window: usize,
    );
}
extern "C" {
    pub fn blst_p2s_to_affine(
        dst: *mut blst_p2_affine,
        points: *const *const blst_p2,
        npoints: usize,
    );
}
extern "C" {
    pub fn blst_p2s_add(ret: *mut blst_p2, points: *const *const blst_p2_affine, npoints: usize);
}
extern "C" {
    pub fn blst_p2s_mult_wbits_precompute_sizeof(wbits: usize, npoints: usize) -> usize;
}
extern "C" {
    pub fn blst_p2s_mult_wbits_precompute(
        table: *mut blst_p2_affine,
        wbits: usize,
        points: *const *const blst_p2_affine,
        npoints: usize,
    );
}
extern "C" {
    pub fn blst_p2s_mult_wbits_scratch_sizeof(npoints: usize) -> usize;
}
extern "C" {
    pub fn blst_p2s_mult_wbits(
        ret: *mut blst_p2,
        table: *const blst_p2_affine,
        wbits: usize,
        npoints: usize,
        scalars: *const *const byte,
        nbits: usize,
        scratch: *mut limb_t,
    );
}
extern "C" {
    pub fn blst_p2s_mult_pippenger_scratch_sizeof(npoints: usize) -> usize;
}
extern "C" {
    pub fn blst_p2s_mult_pippenger(
        ret: *mut blst_p2,
        points: *const *const blst_p2_affine,
        npoints: usize,
        scalars: *const *const byte,
        nbits: usize,
        scratch: *mut limb_t,
    );
}
extern "C" {
    pub fn blst_p2s_tile_pippenger(
        ret: *mut blst_p2,
        points: *const *const blst_p2_affine,
        npoints: usize,
        scalars: *const *const byte,
        nbits: usize,
        scratch: *mut limb_t,
        bit0: usize,
        window: usize,
    );
}
extern "C" {
    pub fn blst_map_to_g1(out: *mut blst_p1, u: *const blst_fp, v: *const blst_fp);
}
extern "C" {
    pub fn blst_map_to_g2(out: *mut blst_p2, u: *const blst_fp2, v: *const blst_fp2);
}
extern "C" {
    pub fn blst_encode_to_g1(
        out: *mut blst_p1,
        msg: *const byte,
        msg_len: usize,
        DST: *const byte,
        DST_len: usize,
        aug: *const byte,
        aug_len: usize,
    );
}
extern "C" {
    pub fn blst_hash_to_g1(
        out: *mut blst_p1,
        msg: *const byte,
        msg_len: usize,
        DST: *const byte,
        DST_len: usize,
        aug: *const byte,
        aug_len: usize,
    );
}
extern "C" {
    pub fn blst_encode_to_g2(
        out: *mut blst_p2,
        msg: *const byte,
        msg_len: usize,
        DST: *const byte,
        DST_len: usize,
        aug: *const byte,
        aug_len: usize,
    );
}
extern "C" {
    pub fn blst_hash_to_g2(
        out: *mut blst_p2,
        msg: *const byte,
        msg_len: usize,
        DST: *const byte,
        DST_len: usize,
        aug: *const byte,
        aug_len: usize,
    );
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blst_opaque {
    _unused: [u8; 0],
}
pub type blst_pairing = blst_opaque;

#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct blst_uniq {
    pub _bindgen_opaque_blob: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_blst_uniq() {
    assert_eq!(
        ::std::mem::size_of::<blst_uniq>(),
        0usize,
        concat!("Size of: ", stringify!(blst_uniq))
    );
    assert_eq!(
        ::std::mem::align_of::<blst_uniq>(),
        1usize,
        concat!("Alignment of ", stringify!(blst_uniq))
    );
}

extern "C" {
    pub static FIAT_SHAMIR_PROTOCOL_DOMAIN: [u8; 16usize];
}
pub type g1_t = blst_p1;
pub type g2_t = blst_p2;
pub type fr_t = blst_fr;
pub type KZGCommitment = g1_t;
pub type KZGProof = g1_t;
pub type BLSFieldElement = fr_t;
pub type Blob = [u8; 131072usize];
#[repr(u32)]
#[doc = " The common return type for all routines in which something can go wrong."]
#[doc = ""]
#[doc = " @warning In the case of @p C_KZG_OK or @p C_KZG_BADARGS, the caller can assume that all memory allocated by the"]
#[doc = " called routines has been deallocated. However, in the case of @p C_KZG_ERROR or @p C_KZG_MALLOC being returned, these"]
#[doc = " are unrecoverable and memory may have been leaked."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum C_KZG_RET {
    #[doc = "< Success!"]
    C_KZG_OK = 0,
    #[doc = "< The supplied data is invalid in some way"]
    C_KZG_BADARGS = 1,
    #[doc = "< Internal error - this should never occur and may indicate a bug in the library"]
    C_KZG_ERROR = 2,
    #[doc = "< Could not allocate memory"]
    C_KZG_MALLOC = 3,
}
#[doc = " Stores the setup and parameters needed for performing FFTs."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct FFTSettings {
    #[doc = "< The maximum size of FFT these settings support, a power of 2."]
    pub max_width: u64,
    #[doc = "< Ascending powers of the root of unity, size `width + 1`."]
    pub expanded_roots_of_unity: *mut fr_t,
    #[doc = "< Descending powers of the root of unity, size `width + 1`."]
    pub reverse_roots_of_unity: *mut fr_t,
    #[doc = "< Powers of the root of unity in bit-reversal permutation, size `width`."]
    pub roots_of_unity: *mut fr_t,
}
#[test]
fn bindgen_test_layout_FFTSettings() {
    const UNINIT: ::std::mem::MaybeUninit<FFTSettings> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FFTSettings>(),
        32usize,
        concat!("Size of: ", stringify!(FFTSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<FFTSettings>(),
        8usize,
        concat!("Alignment of ", stringify!(FFTSettings))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FFTSettings),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expanded_roots_of_unity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FFTSettings),
            "::",
            stringify!(expanded_roots_of_unity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reverse_roots_of_unity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FFTSettings),
            "::",
            stringify!(reverse_roots_of_unity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).roots_of_unity) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FFTSettings),
            "::",
            stringify!(roots_of_unity)
        )
    );
}
#[doc = " Stores the setup and parameters needed for computing KZG proofs."]
#[repr(C)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct KZGSettings {
    #[doc = "< The corresponding settings for performing FFTs"]
    pub fs: *const FFTSettings,
    #[doc = "< G1 group elements from the trusted setup, in Lagrange form bit-reversal permutation"]
    pub g1_values: *mut g1_t,
    #[doc = "< G2 group elements from the trusted setup; both arrays have FIELD_ELEMENTS_PER_BLOB elements"]
    pub g2_values: *mut g2_t,
}
#[test]
fn bindgen_test_layout_KZGSettings() {
    const UNINIT: ::std::mem::MaybeUninit<KZGSettings> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<KZGSettings>(),
        24usize,
        concat!("Size of: ", stringify!(KZGSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<KZGSettings>(),
        8usize,
        concat!("Alignment of ", stringify!(KZGSettings))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KZGSettings),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g1_values) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(KZGSettings),
            "::",
            stringify!(g1_values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g2_values) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(KZGSettings),
            "::",
            stringify!(g2_values)
        )
    );
}
extern "C" {
    #[doc = " Interface functions"]
    pub fn bytes_to_g1(out: *mut g1_t, in_: *const u8) -> C_KZG_RET;
}
extern "C" {
    pub fn bytes_from_g1(out: *mut u8, in_: *const g1_t);
}
extern "C" {
    pub fn bytes_to_bls_field(out: *mut BLSFieldElement, in_: *const u8);
}
extern "C" {
    pub fn load_trusted_setup(out: *mut KZGSettings, in_: *mut FILE) -> C_KZG_RET;
}
extern "C" {
    pub fn free_trusted_setup(s: *mut KZGSettings);
}
extern "C" {
    pub fn compute_aggregate_kzg_proof(
        out: *mut KZGProof,
        blobs: *const Blob,
        n: usize,
        s: *const KZGSettings,
    ) -> C_KZG_RET;
}
extern "C" {
    pub fn verify_aggregate_kzg_proof(
        out: *mut bool,
        blobs: *const Blob,
        expected_kzg_commitments: *const KZGCommitment,
        n: usize,
        kzg_aggregated_proof: *const KZGProof,
        s: *const KZGSettings,
    ) -> C_KZG_RET;
}
extern "C" {
    pub fn blob_to_kzg_commitment(out: *mut KZGCommitment, blob: *mut u8, s: *const KZGSettings);
}
extern "C" {
    pub fn verify_kzg_proof(
        out: *mut bool,
        polynomial_kzg: *const KZGCommitment,
        z: *const BLSFieldElement,
        y: *const BLSFieldElement,
        kzg_proof: *const KZGProof,
        s: *const KZGSettings,
    ) -> C_KZG_RET;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
